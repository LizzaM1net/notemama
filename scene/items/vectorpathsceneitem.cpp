#include "vectorpathsceneitem.h"

#include <QDebug>
#include <rhi/qrhi.h>

VectorPath::LineSegment::LineSegment(QVector2D relEnd)
    : relEnd(relEnd)
{

}

QList<ColorVector2D> VectorPath::LineSegment::generateVertices(QVector2D startPoint, float lineWidth) const
{
    // points are generated by curve connection
    return QList<ColorVector2D>();
}

QVector2D VectorPath::LineSegment::lastPoint(QVector2D startPoint) const
{
    return startPoint + relEnd;
}

QVector2D VectorPath::LineSegment::inTangent() const
{
    return relEnd.normalized();
}

QVector2D VectorPath::LineSegment::outTangent() const
{
    return relEnd.normalized();
}

VectorPath::QuadCurveSegment::QuadCurveSegment(QVector2D relB, QVector2D relC)
    : relB(relB), relC(relC)
{

}

QList<ColorVector2D> VectorPath::QuadCurveSegment::generateVertices(QVector2D startPoint, float lineWidth) const
{
    QVector2D controlPoint = startPoint+relB;
    QVector2D endPoint = startPoint+relC;

    QList<QVector2D> tangentPoints = {-2*startPoint+2*controlPoint, -2*controlPoint+2*endPoint};
    QList<ColorVector2D> curve;
    int points = 40;

    for (int i = 1; i < points-1; i++) {
        float t = float(i)/(points-1.);
        QVector2D point = startPoint*(1.-t)*(1.-t) + 2.*controlPoint*t*(1.-t) + endPoint*t*t;
        QVector2D tangent = tangentPoints[0]*(1.-t) + tangentPoints[1]*t;
        QVector2D normal = QVector2D(tangent.y(), -tangent.x()).normalized();
        curve << ColorVector2D(point, (qSin(i)+1)/2, (qCos(i)+1)/2, 1) + (i%2==0 ? 1 : -1) * normal * lineWidth;
    }
    return curve;
}

QVector2D VectorPath::QuadCurveSegment::lastPoint(QVector2D startPoint) const
{
    return startPoint + relC;
}

QVector2D VectorPath::QuadCurveSegment::inTangent() const
{
    return relB.normalized();
}

QVector2D VectorPath::QuadCurveSegment::outTangent() const
{
    return (relC-relB).normalized();
}

VectorPath::CubicCurveSegment::CubicCurveSegment(QVector2D relB, QVector2D relC, QVector2D relD)
    : relB(relB), relC(relC), relD(relD)
{

}

QList<ColorVector2D> VectorPath::CubicCurveSegment::generateVertices(QVector2D startPoint, float lineWidth) const
{
    QVector2D BPoint = startPoint+relB;
    QVector2D CPoint = startPoint+relC;
    QVector2D endPoint = startPoint+relD;

    QList<QVector2D> tangentPoints = {-3*startPoint+3*BPoint, -3*BPoint+3*CPoint, -3*CPoint+3*endPoint};
    QList<ColorVector2D> curve;
    int points = 40;

    for (int i = 1; i < points-1; i++) {
        float t = float(i)/(points-1.);
        QVector2D point = startPoint*(1.-t)*(1.-t)*(1.-t) + 3.*BPoint*t*(1.-t)*(1.-t) + 3.*CPoint*t*t*(1.-t) + endPoint*t*t*t;
        QVector2D tangent = tangentPoints[0]*(1.-t)*(1.-t) + 2*tangentPoints[1]*t*(1.-t) + tangentPoints[2]*t*t;
        QVector2D normal = QVector2D(tangent.y(), -tangent.x()).normalized();
        curve << ColorVector2D(point, (qSin(i)+1)/2, (qCos(i)+1)/2, 1) + (i%2==0 ? 1 : -1) * normal * lineWidth;
    }
    return curve;
}

QVector2D VectorPath::CubicCurveSegment::lastPoint(QVector2D startPoint) const
{
    return startPoint + relD;
}

QVector2D VectorPath::CubicCurveSegment::inTangent() const
{
    return relB.normalized();
}

QVector2D VectorPath::CubicCurveSegment::outTangent() const
{
    return (relD-relC).normalized();
}

VectorPathSceneItem::VectorPathSceneItem(QVector2D startPoint, QList<VectorPath::Segment *> segments)
    : startPoint(startPoint)
    , segments(segments) {}

VectorPathSceneItem::~VectorPathSceneItem() {
    qDeleteAll(segments);
    delete m_buffer;
}

void VectorPathSceneItem::synchronize(QRhi *rhi, QRhiResourceUpdateBatch *updateBatch) {
    QList<ColorVector2D> vertexData = generateVertices();
    m_verticesCount = vertexData.size();

    if (m_buffer == nullptr) {
        m_buffer = rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::VertexBuffer, vertexData.size()*sizeof(ColorVector2D));
        m_buffer->create();
    } else if (m_buffer->size() < vertexData.size()*sizeof(ColorVector2D)) {
        quint32 newSize = qMax(m_buffer->size()*2, vertexData.size()*sizeof(ColorVector2D));
        m_buffer->setSize(newSize);
        m_buffer->create();
    }

    updateBatch->updateDynamicBuffer(m_buffer, 0, m_buffer->size(), vertexData.data());
}

void VectorPathSceneItem::render(QRhiCommandBuffer *cb) {
    const QRhiCommandBuffer::VertexInput vbufBinding(m_buffer, 0);
    cb->setVertexInput(0, 1, &vbufBinding);

    // cb->draw(m_itemSizes[i]);
    cb->draw(m_verticesCount);
}

QRectF VectorPathSceneItem::boundingRect() {
    return QRect();
}

QList<ColorVector2D> VectorPathSceneItem::generateVertices()
{
    QList<ColorVector2D> points;
    QVector2D point = startPoint;
    QVector2D prevOutTangent;
    for (const VectorPath::Segment* segment : std::as_const(segments)) {
        // curve connection
        QVector2D tangent = (segment->inTangent()+prevOutTangent).normalized();
        QVector2D normal(tangent.y(), -tangent.x());
        float dot = QVector2D::dotProduct(tangent, segment->inTangent());
        if (qFuzzyIsNull(dot))
            continue;
        normal /= dot;

        points << ColorVector2D(point, Qt::black) - m_lineWidth*normal
               << ColorVector2D(point, Qt::black) + m_lineWidth*normal;

        points << segment->generateVertices(point, m_lineWidth);
        point = segment->lastPoint(point);
        prevOutTangent = segment->outTangent();
    }
    // curve end
    QVector2D tangent = (prevOutTangent).normalized();
    QVector2D normal(tangent.y(), -tangent.x());
    points << ColorVector2D(point, Qt::black) - m_lineWidth*normal
           << ColorVector2D(point, Qt::black) + m_lineWidth*normal;
    return points;
}
