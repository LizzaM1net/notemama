#include "vectorpathsceneitem.h"

#include <QDebug>
#include <rhi/qrhi.h>

VectorPath::Segment::Segment() {}

VectorPath::Segment::~Segment() {}

VectorPath::LineSegment::LineSegment(QVector2D end)
    : end(end) {}

QList<ColorVector2D> VectorPath::LineSegment::generateVertices(QVector2D startPoint, float lineWidth) const {
    // points are generated by curve connection
    return QList<ColorVector2D>();
}

QVector2D VectorPath::LineSegment::lastPoint() const {
    return end;
}

QVector2D VectorPath::LineSegment::inTangent(QVector2D startPoint) const {
    return (end-startPoint).normalized();
}

QVector2D VectorPath::LineSegment::outTangent(QVector2D startPoint) const {
    return (end-startPoint).normalized();
}

VectorPath::QuadCurveSegment::QuadCurveSegment(QVector2D b, QVector2D c)
    : b(b), c(c) {}

QList<ColorVector2D> VectorPath::QuadCurveSegment::generateVertices(QVector2D startPoint, float lineWidth) const {
    QList<QVector2D> tangentPoints = {-2*startPoint+2*b, -2*b+2*c};
    QList<ColorVector2D> curve;
    int points = 40;

    for (int i = 1; i < points-1; i++) {
        float t = float(i)/(points-1.);
        QVector2D point = startPoint*(1.-t)*(1.-t) + 2.*b*t*(1.-t) + c*t*t;
        QVector2D tangent = tangentPoints[0]*(1.-t) + tangentPoints[1]*t;
        QVector2D normal = QVector2D(tangent.y(), -tangent.x()).normalized();
        curve << ColorVector2D(point, (qSin(i)+1)/2, (qCos(i)+1)/2, 1) + (i%2==0 ? 1 : -1) * normal * lineWidth;
    }
    return curve;
}

QVector2D VectorPath::QuadCurveSegment::lastPoint() const {
    return c;
}

QVector2D VectorPath::QuadCurveSegment::inTangent(QVector2D startPoint) const {
    return (b-startPoint).normalized();
}

QVector2D VectorPath::QuadCurveSegment::outTangent(QVector2D startPoint) const {
    return (c-b).normalized();
}

VectorPath::CubicCurveSegment::CubicCurveSegment(QVector2D b, QVector2D c, QVector2D d)
    : b(b), c(c), d(d) {}

QList<ColorVector2D> VectorPath::CubicCurveSegment::generateVertices(QVector2D startPoint, float lineWidth) const {
    QList<QVector2D> tangentPoints = {-3*startPoint+3*b, -3*b+3*c, -3*c+3*d};
    QList<ColorVector2D> curve;
    int points = 40;

    for (int i = 1; i < points-1; i++) {
        float t = float(i)/(points-1.);
        QVector2D point = startPoint*(1.-t)*(1.-t)*(1.-t) + 3.*b*t*(1.-t)*(1.-t) + 3.*c*t*t*(1.-t) + d*t*t*t;
        QVector2D tangent = tangentPoints[0]*(1.-t)*(1.-t) + 2*tangentPoints[1]*t*(1.-t) + tangentPoints[2]*t*t;
        QVector2D normal = QVector2D(tangent.y(), -tangent.x()).normalized();
        curve << ColorVector2D(point, (qSin(i)+1)/2, (qCos(i)+1)/2, 1) + (i%2==0 ? 1 : -1) * normal * lineWidth;
    }
    return curve;
}

QVector2D VectorPath::CubicCurveSegment::lastPoint() const {
    return d;
}

QVector2D VectorPath::CubicCurveSegment::inTangent(QVector2D startPoint) const {
    return (b-startPoint).normalized();
}

QVector2D VectorPath::CubicCurveSegment::outTangent(QVector2D startPoint) const {
    return (d-c).normalized();
}

VectorPathSceneItem::VectorPathSceneItem(QVector2D startPoint, QList<VectorPath::Segment *> segments, float lineWidth)
    : startPoint(startPoint)
    , segments(segments)
    , lineWidth(lineWidth) {}

VectorPathSceneItem::~VectorPathSceneItem() {
    qDeleteAll(segments);
    delete m_buffer;
}

void VectorPathSceneItem::synchronize(QRhi *rhi, QRhiResourceUpdateBatch *updateBatch) {
    QList<ColorVector2D> vertexData = generateVertices();
    m_verticesCount = vertexData.size();

    if (m_buffer == nullptr) {
        m_buffer = rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::VertexBuffer, vertexData.size()*sizeof(ColorVector2D));
        m_buffer->create();
    } else if (m_buffer->size() < vertexData.size()*sizeof(ColorVector2D)) {
        quint32 newSize = qMax(m_buffer->size()*2, vertexData.size()*sizeof(ColorVector2D));
        m_buffer->setSize(newSize);
        m_buffer->create();
    }

    updateBatch->updateDynamicBuffer(m_buffer, 0, m_buffer->size(), vertexData.data());
}

void VectorPathSceneItem::render(QRhiCommandBuffer *cb) {
    const QRhiCommandBuffer::VertexInput vbufBinding(m_buffer, 0);
    cb->setVertexInput(0, 1, &vbufBinding);

    cb->draw(m_verticesCount);
}

QRectF VectorPathSceneItem::boundingRect() {
    return QRect();
}

QList<ColorVector2D> VectorPathSceneItem::generateVertices() {
    QList<ColorVector2D> points;
    QVector2D point = startPoint;
    QVector2D prevOutTangent;
    for (const VectorPath::Segment* segment : std::as_const(segments)) {
        // curve connection
        QVector2D tangent = (segment->inTangent(point)+prevOutTangent).normalized();
        QVector2D normal(tangent.y(), -tangent.x());
        float dot = QVector2D::dotProduct(tangent, segment->inTangent(point));
        if (qFuzzyIsNull(dot))
            continue;

        dot = qBound(0.25, dot, 1.);
        normal /= dot;

        points << ColorVector2D(point, Qt::white) - lineWidth*normal
               << ColorVector2D(point, Qt::white) + lineWidth*normal;

        points << segment->generateVertices(point, lineWidth);
        prevOutTangent = segment->outTangent(point);
        point = segment->lastPoint();
    }
    // curve end
    QVector2D tangent = (prevOutTangent).normalized();
    QVector2D normal(tangent.y(), -tangent.x());
    points << ColorVector2D(point, Qt::black) - lineWidth*normal
           << ColorVector2D(point, Qt::black) + lineWidth*normal;
    return points;
}
